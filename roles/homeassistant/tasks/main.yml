---
## Single source of truth for env + hard asserts
- name: Bootstrap env (resolve and validate all variables)
  ansible.builtin.import_tasks: env_boot.yml
  tags: [always]

# THEN: Path safety (uses validated ansible_user)
- name: Fail fast if paths resolve outside target user's home
  ansible.builtin.assert:
    that:
      - ha_stack_dir is search('/home/' ~ ansible_user ~ '/')
      - ha_config_dir is search('/home/' ~ ansible_user ~ '/')
    fail_msg: >
      One or more paths point outside /home/{{ ansible_user }}:
      ha_stack_dir={{ ha_stack_dir }}, ha_config_dir={{ ha_config_dir }}.
      Check inventories/group_vars/all.yml.

# --- New: discover the latest HA release tag (override > latest > stable) ---
- name: Fetch latest Home Assistant Core release from GitHub
  ansible.builtin.uri:
    url: https://api.github.com/repos/home-assistant/core/releases/latest
    method: GET
    return_content: true
    headers:
      Authorization: "Bearer {{ gh_pat }}"
  register: ha_release_latest
  failed_when: ha_release_latest.status not in [200, 304]
  changed_when: false

- name: Parse latest tag into ha_latest (e.g. 2025.10.3)
  ansible.builtin.set_fact:
    ha_latest: "{{ (ha_release_latest.json.tag_name | regex_replace('^v','')) 
                  if (ha_release_latest is defined and
                      ha_release_latest.json is defined and
                      ha_release_latest.json.tag_name is defined) else '' }}"
  changed_when: false

- name: Decide ha_version (override > latest > stable fallback)
  ansible.builtin.set_fact:
    ha_version: >-
      {{ (ha_version_override | default('') | trim)
         if (ha_version_override | default('') | trim | length) > 0 else
         (ha_latest | default('') | trim if (ha_latest | default('') | trim | length) > 0 else 'stable') }}
  changed_when: false

# Fast, reliable facts (no sudo) to avoid stalls on "Gathering Facts"
- name: Gather facts without sudo (fast & reliable)
  ansible.builtin.setup:
    gather_subset: ['min']

# Optional: ensure the current user is in the docker group (needs re-login)
- name: Ensure user is in 'docker' group (requires re-login to take effect)
  ansible.builtin.user:
    name: "{{ ansible_user | default(ansible_env.USER) }}"
    groups: docker
    append: true
  when: manage_docker_group | default(false)

# Create base directories for the stack and HA config
- name: Ensure HA base directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
    owner: "{{ ansible_user_id }}"
    group: "{{ ansible_user_gid | default(ansible_user_id) }}"
  loop:
    - "{{ ha_stack_dir }}"
    - "{{ ha_config_dir }}"

- name: Ensure HA backup directory exists on host
  ansible.builtin.file:
    path: "{{ ha_native_backup_dir }}"
    state: directory
    owner: "{{ runtime_uid }}"
    group: "{{ runtime_gid }}"
    mode: "0755"
  become: true
  when: "'ha_target' in group_names"

- name: Fail fast if we cannot write to ha_stack_dir
  ansible.builtin.file:
    path: "{{ ha_stack_dir }}/.permcheck"
    state: touch
    mode: "0644"
  changed_when: false

# Check the homelab-config folder (HA)
- name: Ensure ha_config_dir exists
  ansible.builtin.file:
    path: "{{ ha_config_dir }}"
    state: directory

# Copy repo config into target config root (mandatory since git clone step was removed)
- name: Stat | source repo dir (ha_config_repo_dir)
  ansible.builtin.stat:
    path: "{{ ha_config_repo_dir }}"
  register: _src
  delegate_to: localhost
  run_once: true

- name: Fail if source repo dir missing
  ansible.builtin.fail:
    msg: "Source dir not found: {{ ha_config_repo_dir }}"
  when: not _src.stat.exists

# Set hostname (so one USB works for both HA and PiHole)
- name: Set hostname to ha_hostname
  ansible.builtin.hostname:
    name: "{{ ha_hostname }}"
  become: true
  when: "'ha_target' in group_names and ansible_hostname != ha_hostname"

# Ensure target can run apt/system tasks without prompts (CI-friendly)
- name: Include sudoers setup for target
  ansible.builtin.include_tasks: sudoers.yml
  when: "'ha_target' in group_names and (enable_target_passwordless_sudo | default(true))"

# Optional OS updates (runs only when --tags os_update is used)
- name: Include OS updates (opt-in via tags)
  include_tasks:
    file: os-update.yml
    apply:
      tags:
        - os_update
  tags: [os_update, never]

# Prepare target packages (Docker/Compose + rsync) before we sync the repo
- name: Include docker install for target
  ansible.builtin.include_tasks: docker-install.yml
  when: "'ha_target' in group_names"

# Argon One case fan configuration (optional)
- name: Include Argon One fan setup
  ansible.builtin.include_tasks: argon-fan.yml
  when:
    - "'ha_target' in group_names"
    - enable_argon_fan | default(false) | bool

- name: Sync repo from controller â†’ target (ha_target group)
  ansible.posix.synchronize:
    src: "{{ lookup('env', 'HOME') }}/homelab/config/homeassistant/"
    dest: "{{ ha_config_dir }}/"
    delete: yes
    compress: yes
    rsync_opts:
      - "--no-owner"
      - "--no-group"
      - "--no-perms"
      - "--omit-dir-times"
      - "--exclude=**.db*"
      - "--exclude=*.log*"
      - "--exclude=.storage/"
      - "--exclude=deps/"
  when: "'ha_target' in group_names"

- name: Sync repo locally (ha group)
  ansible.builtin.command: >
    rsync -a --delete --no-owner --no-group --no-perms --omit-dir-times
           --exclude=".storage/" --exclude="deps/" --exclude="**.db*" --exclude="*.log*"
           {{ lookup('env', 'HOME') }}/homelab/config/homeassistant/
           {{ ha_config_dir }}/
  when: "'ha' in group_names"
  changed_when: false

# Debug which directory we validate (helps in local vs CI)
- name: Debug | ha_config_dir being validated
  ansible.builtin.debug:
    msg: "Validating configuration.yaml in: {{ ha_config_dir }}"

- name: Verify configuration.yaml present in ha_config_dir
  ansible.builtin.stat:
    path: "{{ ha_config_dir }}/configuration.yaml"
  register: ha_cfg_stat

- name: Fail if configuration.yaml missing
  ansible.builtin.fail:
    msg: "Expected configuration.yaml in {{ ha_config_dir }} (we no longer git clone in this role)."
  when: not ha_cfg_stat.stat.exists

# pre-docker-compose: Ensure service data dirs exist with correct ownership
- name: Ensure service data dirs exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ runtime_uid }}"
    group: "{{ runtime_gid }}"
    mode: "0750"
  loop: "{{ service_data_dirs }}"
  changed_when: false

- name: Stat HA version lock file
  ansible.builtin.stat:
    path: "{{ ha_stack_dir }}/.ha_version.lock"
  register: ha_lock_stat

- name: Read HA version lock (remote)
  ansible.builtin.slurp:
    src: "{{ ha_stack_dir }}/.ha_version.lock"
  register: ha_lock_slurp
  when: ha_lock_stat.stat.exists

- name: Set ha_version_locked fact (from lock)
  ansible.builtin.set_fact:
    ha_version_locked: "{{ (ha_lock_slurp.content | b64decode).strip() }}"
  when: ha_lock_stat.stat.exists

- name: Derive ha_effective_version (lock > discovered)
  ansible.builtin.set_fact:
    ha_effective_version: >-
      {{ ha_version_locked | default(ha_version) }}

- name: Bootstrap lock file on first run (pin to ha_version_locked or ha_version)
  ansible.builtin.copy:
    dest: "{{ ha_stack_dir }}/.ha_version.lock"
    mode: "0644"
    content: "{{ ha_effective_version }}\n"
  when: not ha_lock_stat.stat.exists

# Render docker-compose (always)
- name: Render docker-compose
  ansible.builtin.template:
    src: "docker-compose.yml.j2"
    dest: "{{ ha_stack_dir }}/docker-compose.yml"
    mode: "0644"

# Optional: pull images & up -d when explicitly asked
- name: Include containers update (opt-in via tags)
  include_tasks: containers-update.yml
  tags: [containers_update, ha_update]

# Bring up/update the stack (CLI, no Python SDK required, using CF_TUNNEL_TOKEN as env var)
- name: Bring up/update (no env file)
  no_log: true
  ansible.builtin.shell: |
    sg docker -c 'docker compose -p {{ ha_project | quote }} -f {{ ha_stack_dir }}/docker-compose.yml up -d'
  args:
    chdir: "{{ ha_stack_dir }}"
  environment: "{{ compose_global_env }}"
  register: compose_up
  changed_when: false

- name: Derive changed=true from compose output (stdout+stderr)
  ansible.builtin.set_fact:
    _compose_changed: >-
      {{
        ('Recreated'  in ((compose_up.stdout|default('')) ~ (compose_up.stderr|default('')))) or
        ('Recreating' in ((compose_up.stdout|default('')) ~ (compose_up.stderr|default('')))) or
        ('Created'    in ((compose_up.stdout|default('')) ~ (compose_up.stderr|default('')))) or
        ('Creating'   in ((compose_up.stdout|default('')) ~ (compose_up.stderr|default('')))) or
        ('Starting'   in ((compose_up.stdout|default('')) ~ (compose_up.stderr|default(''))))
      }}

- name: Mark task changed if compose created/recreated/started containers
  ansible.builtin.debug:
    msg: "Compose up ran."
  changed_when: _compose_changed

- name: Write HA port to artifact (for GitHub workflow verification)
  ansible.builtin.copy:
    content: "{{ ha_host_port }}\n"
    dest: "{{ ha_stack_dir }}/.ha_port"
    mode: "0644"
  when: "'ha_target' in group_names"

# Show compose result (nice for troubleshooting)
- name: Show compose result (debug)
  ansible.builtin.debug:
    var: compose_up

# ============================================================================
# OPTIONAL: FRESH INSTALL (clean .storage before disaster recovery)
# ============================================================================
# Use -e fresh_install=true to wipe .storage/ before any restore/bootstrap
# This ensures truly fresh state regardless of restore method:
#   - Backup restore â†’ clean slate + backup data
#   - Seedbox restore â†’ clean slate + seedbox data
#   - Bootstrap â†’ clean slate + new user only
# ============================================================================

- name: Clean .storage for fresh install (opt-in via -e fresh_install=true)
  ansible.builtin.file:
    path: "{{ ha_config_dir }}/.storage"
    state: absent
  become: true
  when:
    - "'ha_target' in group_names"
    - fresh_install | default(false) | bool

- name: Show fresh install notice
  ansible.builtin.debug:
    msg: "ğŸ†• Fresh install mode - .storage/ cleaned, disaster recovery will restore to clean state"
  when:
    - "'ha_target' in group_names"
    - fresh_install | default(false) | bool

# ============================================================================
# DISASTER RECOVERY LOGIC
# Priority: Local backup > Seedbox > Bootstrap (fresh install)
#
# SKIP in maintenance mode: When maintenance_mode=true, we only deploy config
# from Git and leave runtime state (.storage/, database) untouched.
# ============================================================================

# =============================================================================
# DEPLOYMENT MODE BANNER - Clear visibility in logs!
# =============================================================================
- name: "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  ansible.builtin.debug:
    msg: "{{ 'ğŸ”§ MAINTENANCE MODE' if (maintenance_mode | default(false) | bool) else 'ğŸ”„ DISASTER RECOVERY MODE' }}"
  when: "'ha_target' in group_names"

- name: Show deployment mode details
  ansible.builtin.debug:
    msg: "{{ 'â­ï¸ Skipping backup restore, config from Git only' if (maintenance_mode | default(false) | bool) else '   Will restore runtime state from backup' }}"
  when: "'ha_target' in group_names"

- name: "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  ansible.builtin.debug:
    msg: ""
  when: "'ha_target' in group_names"

# Check for local backups FIRST (skip in maintenance mode)
- name: Check for backups in native backup dir
  ansible.builtin.find:
    paths: "{{ ha_native_backup_dir }}"
    patterns: "*.tar"
  register: available_backups
  when:
    - "'ha_target' in group_names"
    - not (maintenance_mode | default(false) | bool)

# Set flag to track if restore was successful
- name: Initialize restore status
  ansible.builtin.set_fact:
    restore_completed: false
  when:
    - "'ha_target' in group_names"
    - not (maintenance_mode | default(false) | bool)

# PATH 1: Local backup found â†’ restore from backup (runtime state only)
- name: Restore from local backup
  block:
    - include_tasks: backup-restore.yml
    - name: Mark restore as completed
      ansible.builtin.set_fact:
        restore_completed: true
  rescue:
    - name: Local backup restore failed, will try seedbox
      ansible.builtin.debug:
        msg: "âš ï¸ Local backup restore failed, attempting seedbox restore"
  when:
    - "'ha_target' in group_names"
    - not (maintenance_mode | default(false) | bool)
    - available_backups.matched > 0

# PATH 2: No local backup OR local backup failed â†’ try seedbox
- name: Restore from seedbox (fallback)
  block:
    - include_tasks: seedbox-restore.yml
    # CRITICAL: Only mark as completed if seedbox was actually found and restored
    - name: Mark restore as completed
      ansible.builtin.set_fact:
        restore_completed: true
      when: seedbox_found | default(false)
  when:
    - "'ha_target' in group_names"
    - not (maintenance_mode | default(false) | bool)
    - not restore_completed | default(false)

# PATH 3: All restores failed â†’ bootstrap fresh install (create first user)
- name: Bootstrap authentication for fresh install
  import_tasks: bootstrap-auth.yml
  when:
    - "'ha_target' in group_names"
    - not (maintenance_mode | default(false) | bool)
    - ha_bootstrap_enable | default(true)
    - not restore_completed | default(false)
  tags: [ha_bootstrap]

# Summary of what happened
- name: Deployment summary
  ansible.builtin.debug:
    msg: >-
      {{ 'ğŸ”§ Maintenance deploy completed - config synced from Git'
         if (maintenance_mode | default(false) | bool)
         else ('âœ… DR restore completed successfully' if restore_completed | default(false) else 'ğŸ†• Fresh install - bootstrap ran') }}
  when: "'ha_target' in group_names"
