---
# --- New: discover the latest HA release tag (override > latest > stable) ---
- name: Fetch latest Home Assistant Core release from GitHub
  ansible.builtin.uri:
    url: https://api.github.com/repos/home-assistant/core/releases/latest
    method: GET
    return_content: true
    headers: >-
      {{
        {'Authorization': 'Bearer ' + github_token}
        if (github_token | default('') | length) > 0 else {}
      }}
  register: ha_release_latest
  failed_when: false
  changed_when: false

- name: Parse latest tag into ha_latest (e.g. 2025.10.3)
  ansible.builtin.set_fact:
    ha_latest: "{{ (ha_release_latest.json.tag_name | regex_replace('^v','')) 
                  if (ha_release_latest is defined and
                      ha_release_latest.json is defined and
                      ha_release_latest.json.tag_name is defined) else '' }}"
  changed_when: false

- name: Decide ha_version (override > latest > stable fallback)
  ansible.builtin.set_fact:
    ha_version: >-
      {{ (ha_version_override | default('') | trim)
         if (ha_version_override | default('') | trim | length) > 0 else
         (ha_latest | default('') | trim if (ha_latest | default('') | trim | length) > 0 else 'stable') }}
  changed_when: false

# 0) Fast, reliable facts (no sudo) to avoid stalls on "Gathering Facts"
- name: Gather facts without sudo (fast & reliable)
  ansible.builtin.setup:
    gather_subset: ['min']

# 1): resolve sensitive vars from either a provided .env (local) or CI env/extra-vars (pipeline)
# 1 A) If env_file is provided → read from .env (dotenv/properties)
- name: Load required vars from .env when env_file is provided
  ansible.builtin.set_fact:
    github_username: "{{ lookup('ini', 'GITHUB_USERNAME file=' + env_file + ' type=properties') }}"
    github_pat:       "{{ lookup('ini', 'GITHUB_PAT file='       + env_file + ' type=properties') }}"
    cf_tunnel_id:     "{{ lookup('ini', 'CF_TUNNEL_ID file='     + env_file + ' type=properties') }}"
    cf_hostname:      "{{ lookup('ini', 'CF_HOSTNAME file='      + env_file + ' type=properties') }}"
    cf_tunnel_token:  "{{ lookup('ini', 'CF_TUNNEL_TOKEN file='  + env_file + ' type=properties') }}"
  when: env_file is defined

# 1 B) If env_file is NOT provided → pull from OS env or passed -e vars (CI-friendly)
- name: Load required vars from OS environment when no env_file is provided
  ansible.builtin.set_fact:
    github_username: "{{ github_username | default(lookup('env','GITHUB_USERNAME'), true) }}"
    github_pat:       "{{ github_pat       | default(lookup('env','GITHUB_PAT'), true) }}"
    cf_tunnel_id:     "{{ cf_tunnel_id     | default(lookup('env','CF_TUNNEL_ID'), true) }}"
    cf_hostname:      "{{ cf_hostname      | default(lookup('env','CF_HOSTNAME'), true) }}"
    cf_tunnel_token:  "{{ cf_tunnel_token  | default(lookup('env','CF_TUNNEL_TOKEN'), true) }}"
  when: env_file is not defined

# 1 C) Fast fail for token mode
- name: Assert GitHub tokens present (local & CI)
  ansible.builtin.assert:
    that:
      - (github_username | default('')) | length > 0
      - (github_pat       | default('')) | length > 0
    fail_msg: "Missing GITHUB_USERNAME or GITHUB_PAT (expected via env_file of -e)."

- name: Assert CF_TUNNEL_TOKEN present when cloudflared enabled
  ansible.builtin.assert:
    that:
      - (cf_tunnel_token | default('')) | length > 0
    fail_msg: "enable_cloudflared=true maar CF_TUNNEL_TOKEN ontbreekt."
  when: (enable_cloudflared | default(false))

# 1 D) Optional: ensure the current user is in the docker group (needs re-login)
- name: Ensure user is in 'docker' group (requires re-login to take effect)
  ansible.builtin.user:
    name: "{{ ansible_user | default(ansible_env.USER) }}"
    groups: docker
    append: true
  when: manage_docker_group | default(false)

# 2) Create base directories for the stack and HA config
- name: Ensure HA base directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
    owner: "{{ ansible_user_id }}"
    group: "{{ ansible_user_gid | default(ansible_user_id) }}"
  loop:
    - "{{ ha_stack_dir }}"
    - "{{ ha_config_dir }}"

- name: Fail fast if we cannot write to ha_stack_dir
  ansible.builtin.file:
    path: "{{ ha_stack_dir }}/.permcheck"
    state: touch
    mode: "0644"
  changed_when: false
  failed_when: result is failed
  register: result

# 3) Check the homelab-config folder (HA)
- name: Ensure ha_config_dir exists
  ansible.builtin.file:
    path: "{{ ha_config_dir }}"
    state: directory

# Copy repo config into target config root (mandatory since git clone step was removed)
- name: Stat | source repo dir (ha_config_repo_dir)
  ansible.builtin.stat:
    path: "{{ ha_config_repo_dir }}"
  register: _src

- name: Fail if source repo dir missing
  ansible.builtin.fail:
    msg: "Source dir not found: {{ ha_config_repo_dir }}"
  when: not _src.stat.exists

- name: Sync repo → ha_config_dir
  ansible.builtin.command: >
     rsync -a --delete --no-owner --no-group --no-perms --omit-dir-times
            --exclude=".storage/backups/" --exclude="deps/"
            {{ ha_config_repo_dir }}/
            {{ ha_config_dir }}/
  changed_when: false

# Debug which directory we validate (helps in local vs CI)
- name: Debug | ha_config_dir being validated
  ansible.builtin.debug:
    msg: "Validating configuration.yaml in: {{ ha_config_dir }}"

- name: Verify configuration.yaml present in ha_config_dir
  ansible.builtin.stat:
    path: "{{ ha_config_dir }}/configuration.yaml"
  register: ha_cfg_stat

- name: Fail if configuration.yaml missing
  ansible.builtin.fail:
    msg: "Expected configuration.yaml in {{ ha_config_dir }} (we no longer git clone in this role)."
  when: not ha_cfg_stat.stat.exists

# 5) Classic Cloudflared only: ensure /etc/cloudflared exists on target
- name: Ensure Cloudflared directory exists (ONLY for classic JSON mode)
  ansible.builtin.file:
    path: "{{ cf_dir }}"
    state: directory
    mode: "0755"
  when: enable_cloudflared | default(false) and (cf_tunnel_token | default('') | length == 0)

# 6) Classic mode: verify/copy credentials from controller (skipped when token is used)
- name: Check Cloudflared creds exist on controller (classic mode)
  ansible.builtin.stat:
    path: "{{ cf_creds_src | default('') }}"
  register: cf_creds
  delegate_to: localhost
  run_once: true
  when: enable_cloudflared | default(false) and (cf_tunnel_token | default('') | length == 0)

- name: Abort if Cloudflared credentials are missing (classic mode)
  ansible.builtin.assert:
    that: cf_creds.stat.exists
    fail_msg: "Cloudflared creds not found on controller: {{ cf_creds_src }}"
  when: enable_cloudflared | default(false) and (cf_tunnel_token | default('') | length == 0)

- name: Copy Cloudflared credentials to target (classic mode)
  ansible.builtin.copy:
    src: "{{ cf_creds_src }}"
    dest: "{{ cf_dir }}/{{ cf_tunnel_id }}.json"
    mode: "0600"
  when: enable_cloudflared | default(false) and (cf_tunnel_token | default('') | length == 0)

# 7) Classic mode: render /etc/cloudflared/config.yml (skipped when token is used)
- name: Render Cloudflared config (classic mode)
  ansible.builtin.template:
    src: "cloudflared-config.yml.j2"
    dest: "{{ cf_dir }}/config.yml"
    mode: "0644"
  when: enable_cloudflared | default(false) and (cf_tunnel_token | default('') | length == 0)

# 8) Render docker-compose (always)
- name: Render docker-compose
  ansible.builtin.template:
    src: "docker-compose.yml.j2"
    dest: "{{ ha_stack_dir }}/docker-compose.yml"
    mode: "0644"

# 9) Bring up/update the stack (CLI, no Python SDK required)
# 9 A) Local/dev path: use --env-file so compose reads all keys from your .env
- name: Bring up/update the stack (CLI) using --env-file when provided
  ansible.builtin.command:
    cmd: >
      docker compose
      --env-file "{{ env_file }}"
      -p "{{ ha_stack_name | default('ha-stack-ansible') }}"
      -f "{{ ha_stack_dir }}/docker-compose.yml"
      up -d
  register: compose_up_envfile
  changed_when: >
    ('Recreated' in (compose_up_envfile.stderr | default(''))) or
    ('Created'   in (compose_up_envfile.stderr | default(''))) or
    ('Starting'  in (compose_up_envfile.stderr | default('')))
  when: env_file is defined

# 9 B) CI/pipeline path: no env_file → pass token only as process env for this command
- name: Bring up/update the stack (CLI) passing token via process env (CI-friendly)
  ansible.builtin.command:
    cmd: >
      docker compose
      {% if env_file is defined and env_file|length > 0 %} --env-file {{ env_file | quote }} {% endif %}
      -p "{{ ha_stack_name | default('ha-stack-ansible') }}"
      -f "{{ ha_stack_dir }}/docker-compose.yml"
      up -d
  environment:
    CF_TUNNEL_TOKEN: "{{ CF_TUNNEL_TOKEN | default(lookup('env','CF_TUNNEL_TOKEN'), true) | default(omit) }}"
  register: compose_up
  changed_when: >
    ('Recreating' in compose_up.stdout) or
    ('Creating' in compose_up.stdout) or
    ('Starting' in compose_up.stdout)

# 10) Show compose result (nice for troubleshooting)
- name: Show compose result (debug)
  ansible.builtin.debug:
    var: compose_up

# 11) Bootstrap new user
- import_tasks: bootstrap-auth.yml
  when: ha_bootstrap_enable | default(true)
  tags: [ha_bootstrap]