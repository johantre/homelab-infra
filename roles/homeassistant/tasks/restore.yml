---
# Restore Home Assistant configuration from backup
# CRITICAL: Restore should only run when explicitly requested
- name: Assert restore is intentionally requested (fail if accidentally triggered)
  ansible.builtin.assert:
    that:
      - "'restore' in ansible_run_tags"
    fail_msg: |
      ❌ RESTORE TASK TRIGGERED WITHOUT EXPLICIT TAG! ❌
      Restores should ONLY run when explicitly requested with --tags restore
      This is a safety measure to prevent accidental data loss.
    success_msg: "✅ Restore explicitly requested via tags - proceeding with caution"
  tags: [restore, always]

## Single source of truth for env (needed for CF_TUNNEL_TOKEN)
- name: Bootstrap env for restore (CF_TUNNEL_TOKEN)
  ansible.builtin.import_tasks: env_boot.yml
  tags: [always]

- name: Assert backup directory exists
  ansible.builtin.stat:
    path: "{{ ha_backups_dir }}"
  register: _bk_dir
  failed_when: not _bk_dir.stat.exists
  tags: [restore]

- name: Find all backups (when no specific backup given)
  ansible.builtin.find:
    paths: "{{ ha_backups_dir }}"
    patterns: "ha-config-*.tar.gz"
    file_type: file
    recurse: no
  register: _found_backups
  when: ha_restore_backup is not defined or ha_restore_backup | length == 0
  tags: [restore]

- name: Determine backup to restore (latest)
  ansible.builtin.set_fact:
    _restore_file: "{{ (_found_backups.files | sort(attribute='mtime', reverse=True) | first).path }}"
  when:
    - ha_restore_backup is not defined or ha_restore_backup | length == 0
    - _found_backups.files | length > 0
  tags: [restore]

- name: Determine backup to restore (specific)
  ansible.builtin.set_fact:
    _restore_file: "{{ ha_backups_dir }}/{{ ha_restore_backup }}"
  when: ha_restore_backup is defined and ha_restore_backup | length > 0
  tags: [restore]

- name: Fail if no backup found
  ansible.builtin.fail:
    msg: "No backup found in {{ ha_backups_dir }}"
  when: _restore_file is not defined
  tags: [restore]

- name: Verify backup file exists
  ansible.builtin.stat:
    path: "{{ _restore_file }}"
  register: _restore_stat
  failed_when: not _restore_stat.stat.exists
  tags: [restore]

- name: Show which backup will be restored
  ansible.builtin.debug:
    msg: "Restoring from: {{ _restore_file }}"
  tags: [restore]

- name: Confirm restore (pause for safety)
  ansible.builtin.pause:
    prompt: "About to restore {{ _restore_file }}. Press ENTER to continue, Ctrl+C to abort"
  when: ha_restore_confirm | default(true) | bool
  tags: [restore]

- name: Stop HA stack before restore
  ansible.builtin.shell: |
    sg docker -c 'docker compose -p {{ ha_project | quote }} -f {{ ha_stack_dir }}/docker-compose.yml down'
  args:
    chdir: "{{ ha_stack_dir }}"
  environment: "{{ compose_global_env }}"
  register: _compose_down
  changed_when: true
  tags: [restore]

- name: Show compose down result
  ansible.builtin.debug:
    var: _compose_down
  tags: [restore]

- name: Backup current config (safety net before restore)
  ansible.builtin.command:
    cmd: >
      tar -czf {{ ha_backups_dir }}/pre-restore-{{ ansible_date_time.iso8601_basic_short }}.tar.gz
      -C {{ ha_config_dir }}/.. {{ ha_config_dir | basename }}
  args:
    chdir: "{{ ha_config_dir }}/.."
  when: ha_restore_safety_backup | default(true) | bool
  changed_when: true
  tags: [restore]

- name: Extract backup to config dir
  ansible.builtin.unarchive:
    src: "{{ _restore_file }}"
    dest: "{{ ha_config_dir }}"
    remote_src: yes
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
  tags: [restore]

- name: Fix ownership recursively (critical for restore)
  ansible.builtin.file:
    path: "{{ ha_config_dir }}"
    owner: "{{ runtime_uid }}"
    group: "{{ runtime_gid }}"
    recurse: yes
    state: directory
  tags: [restore]

- name: Verify configuration.yaml exists after restore
  ansible.builtin.stat:
    path: "{{ ha_config_dir }}/configuration.yaml"
  register: _cfg_check
  failed_when: not _cfg_check.stat.exists
  tags: [restore]

- name: Start HA stack after restore
  ansible.builtin.shell: |
    sg docker -c 'docker compose -p {{ ha_project | quote }} -f {{ ha_stack_dir }}/docker-compose.yml up -d'
  args:
    chdir: "{{ ha_stack_dir }}"
  environment: "{{ compose_global_env }}"
  register: _compose_up
  changed_when: true
  tags: [restore]

- name: Show compose up result
  ansible.builtin.debug:
    var: _compose_up
  tags: [restore]

- name: Wait for HA to be ready (health check)
  ansible.builtin.uri:
    url: "http://localhost:{{ ha_host_port }}/"
    status_code: 200
    timeout: 5
  register: _ha_health
  retries: 30
  delay: 2
  until: _ha_health.status == 200
  failed_when: false
  tags: [restore]

- name: Check if cloudflared is running (when enabled)
  ansible.builtin.shell: |
    sg docker -c 'docker ps --filter "name=cloudflared" --format "{{ '{{' }}.Names{{ '}}' }}"'
  register: _cf_running
  changed_when: false
  when: enable_cloudflared | default(false)
  tags: [restore]

- name: Restore summary
  ansible.builtin.debug:
    msg:
      - "✅ Restore completed successfully!"
      - "Restored from: {{ _restore_file }}"
      - "HA Status: {{ 'Running' if _ha_health.status == 200 else 'Check manually' }}"
      - "Cloudflared: {{ 'Running' if (_cf_running.stdout | default('') | length > 0) else 'Not running (check logs)' }}"
      - "Access HA at: http://localhost:{{ ha_host_port }}"
  tags: [restore]